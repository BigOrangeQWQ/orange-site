---
title: "LLM Ideas"
date: 2025-09-19T00:08:01+08:00
slug: 2025-09-19-my-site
type: posts
draft: false
categories:
  - Computer
---

这里记录着我个人对 LLM Agent 的 Ideas

## LLM 现状

在这篇文章发出的时候，LLM 的能力在客观上依旧不足。但是 LLM 本身的能力边界依然有待开发
大部分的 Agent 处于野蛮探索的阶段，本文基于若干个符合直觉的假设，大胆提出未来 Agent 的发展方向。

## 假设

- LLM 本质上是一个混沌系统。
- 软件链条极度脆弱，链条上的任意一个节点的崩坏都会导致整条链路的失败。
- 消耗更多的 Token， 达成更好的生成效果
- 单次生成承担任务越多，生成出来的事物越畸形扭曲

## 推导

基于上面的四条假设我们可以推导出很多东西

1. LLM 在合成软件的时候，它生成的内容越少，生成的代码越可靠
2. 提示词工程是必要的，其是混沌系统的靶向药，也是限制工作量的紧箍咒
3. 当前客观条件下，单一对话完成一个项目时，无论速度还是效果都不尽人意
4. 非技术人员和 LLM 均存在大量难以明确洞悉的技术盲区

这四点将和前面的假设一起做出一个我个人认为符合直觉的 Agent 设计

1. 生成将以函数为单位，每一个函数对应一个提示词，对于没有提示词的函数，交由 LLM 进行总结


2. LLM 表示出类似人类心智的事情，那么 Agent 可以应用上项目管理的模式
  - 即一个 Agent 存在 3 个及以上的 SubAgent，其中每个 SubAgent 代表自身不同的身份
  - Leader(SubAgent) 负责项目整体逻辑/需求的调整，其负责提供使用的技术栈和所要实现的整体框架之类..
  - Mentor(SubAgent) 会接下 Leader 所产生的某一个模块方向的业务，生成对应的 TODO List，也负责验收
  - Worker(SubAgent) 负责接收 Mentor 的 TODO 项，每次根据 TODO 项里对函数的具体描述生成指定代码和单测。看起来是很慢的设计，但是对于 Mentor 来说，其可以同时启动无数个 Worker。后续进一步可以构建类似的 Thread Pool 的结构，用来并发进行工作。

这样会催生一个巨大的 `.llm` 缓存文件夹，从模块到函数都有详细的 TLDR 或直接为对应产生此函数的 Prompt

该结构存在很多好处

第一个好处是，对于任何一个函数/模块的设计，我们都可以在任意时刻任意调整其 `Prompt` 而后打断重来，因为 `Worker` 一次生成只对应一个函数，对于提示词的修改波及范围且影响不到整体的生成逻辑。这样避免了提示词和用户输入的互相污染，因为这在 `Agent` 层面已经被隔离出来了。

第二个好处是，它可以随意的插入到任何一个项目里面，可以通过这样的结构去反推任何一个已经存在的项目的函数功能或逻辑，这样 `LLM` 接手或项目维护者借助 `LLM` 生成代码会有很明显的指向型，当前的 `Agent` 对于已经存在的项目其实是有些措手不及的，但是这种结构的话对于项目维护者来说非常有帮助，项目维护者可以让 `LLM` 精确的触及到项目的任何一个角落。

第三个好处是，`LLM` 的上下文劣势和因单次工作量太大罢工的情况在这种结构下被消融了，因为每次工作只是对于单个函数的设计。
第四个好处是，未来的工具链如果需要 `Agent` 自生成自调用或者是调用其他工具链/模块的时候，其他工具链和模块可以直接用这套模式所产生出来的缓存进行接手。

我想这套结构的优势不止于此，如果 `Agent` 使用 `monorepo` 的这种形式时去合成软件，这套流程依然能大放光彩。


3. 记忆化设计，对于 Worker 而言，记忆和上下文永远是不够用的，在非模型本身的能力的情况下，记忆的压缩一定是有损的。
但是换一个方向思考，记忆压缩有损，但记忆不一定有用。
比如， Worker 对于已经实现的 TODO 项，其不需要实现该 TODO 项的任何上下文，只保留 TODO 项里面对于该函数的描述，知道其存在这个函数和使用即可。
我们在设计对话的数据储存时，只需要增一个 _task_ 字段标识当前上下文为哪个 TODO 项，后续扬弃掉即可。
这类似于一个巨大的任务队列，任务完成时记忆也该弹出。

4. ...

### 其他的一些小想法和可能性

1. 效率问题

这套架构的效率一定比普通的 Agent 高效，即使一次生成一个函数这种看似反直觉的设计，其也可能会比普通 Agent 高效。其宗旨就是**花多轮优化多个函数，不如一次生成一个函数。**

2. Agent 信任链条

对于 Agent 每次输出的结果，它一定是具有一个可信度的值（比如说大家一眼就能看出来它生成出来的东西简直烂爆了）


设可信度数组为 $C = [c_1, c_2, c_3, ..., c_n]$，其中每个 $c_i \in (0, 1]$，那么整体可信度为

$$
\text{Overall Credibility} = \prod_{i=1}^{n} c_i = c_1 \times c_2 \times c_3 \times ... \times c_n
$$

我们需要整体可信度大于最小可信度阈值

$$
\prod_{i=1}^{n} c_i > c_{\text{min}}
$$

3. LLM Review

 对于代码的检视验收是 Agent 里面最脆弱也是最垃圾的一环，谁能把这个阶段优化到登峰造极，Agent 就算是一个 while loop 也可以循环出来。




